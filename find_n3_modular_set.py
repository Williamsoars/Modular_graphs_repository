import math
from itertools import combinations
from sympy import isprime, n_order, nextprime, primefactors


# ---------- Basic Utilities ----------

def lcm_list(numbers):
    """Compute LCM of a list of integers."""
    if not numbers:
        return 1
    lcm = numbers[0]
    for n in numbers[1:]:
        lcm = (lcm * n) // math.gcd(lcm, n)
    return lcm


def count_unique_graphs(orders):
    """
    Counts distinct modular graphs generated by LCM-closure
    of all subsets of the order list.
    """
    lcm_set = set()
    for r in range(len(orders) + 1):
        for combo in combinations(orders, r):
            lcm_set.add(lcm_list(combo))
    return len(lcm_set)


# ---------- Default Arithmetic Condition ----------

def default_factor_condition(p, min_total_factors=6):
    """
    Checks whether p-1 has at least `min_total_factors`
    distinct prime divisors (including 2).
    """
    return len(primefactors(p - 1)) >= min_total_factors


# ---------- Main Search Function ----------

def find_n3_modular_set(
    p_start,
    factor_condition_fn=default_factor_condition,
    p3_search_limit=1000,
    target_graph_count=58
):
    """
    Searches for an N=3 prime set {p1, p2, p3} satisfying:

    â€¢ p2 = p1 + 2 (twin primes)
    â€¢ All p_i satisfy factor_condition_fn(p_i)
    â€¢ All multiplicative orders between primes are distinct
    â€¢ No order divides another (independence condition)
    â€¢ Maximizes number of modular graphs generated

    Parameters
    ----------
    p_start : int
        Starting value for searching p1.
    factor_condition_fn : function
        Function f(p) -> bool to filter primes based on p-1 structure.
    p3_search_limit : int
        Number of local attempts when searching for p3.
    target_graph_count : int
        Stop when this number of modular graphs is reached.

    Returns
    -------
    (primes, orders, graph_count)
    """

    p1 = nextprime(p_start)
    best_count = 0

    print(f"Searching N=3 modular set | Target: {target_graph_count}/64")
    print("Filtering primes via factor_condition_fn(p)")
    print("-" * 50)

    while True:
        if factor_condition_fn(p1):
            p2 = p1 + 2

            if isprime(p2) and factor_condition_fn(p2):

                # --- Local search for p3 ---
                p3 = nextprime(p2 + 10)
                attempts = 0

                while attempts < p3_search_limit:
                    if factor_condition_fn(p3):
                        try:
                            primes = [p1, p2, p3]

                            # Compute all directed orders
                            orders = []
                            for i in range(3):
                                for j in range(3):
                                    if i != j:
                                        orders.append(n_order(primes[i], primes[j]))

                            # --- Distinctness condition ---
                            if len(set(orders)) != 6:
                                raise ValueError

                            # --- Independence condition (no divisibility) ---
                            sorted_orders = sorted(orders)
                            for i in range(6):
                                for j in range(i + 1, 6):
                                    if sorted_orders[j] % sorted_orders[i] == 0:
                                        raise ValueError

                            # --- Count modular graphs ---
                            graph_count = count_unique_graphs(orders)

                            if graph_count > best_count:
                                best_count = graph_count
                                print(f"\nðŸš€ NEW RECORD: {graph_count}/64")
                                print(f"Primes: {primes}")
                                print(f"Factorization p1-1: {primefactors(p1-1)}")
                                print(f"Factorization p2-1: {primefactors(p2-1)}")
                                print(f"Factorization p3-1: {primefactors(p3-1)}")
                                print(f"Orders: {orders}")

                            if graph_count >= target_graph_count:
                                print("\nâœ¨ High-performance modular set found!")
                                return primes, orders, graph_count

                        except Exception:
                            pass

                    p3 = nextprime(p3)
                    attempts += 1

        p1 = nextprime(p1)

        if p1 % 5000 == 0:
            print(f"Scanning p1 > {p1}...", end='\r')
